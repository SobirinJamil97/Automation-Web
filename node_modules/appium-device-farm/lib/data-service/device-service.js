"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unblockDevice = exports.updateCmdExecutedTime = exports.updateDevice = exports.getDevice = exports.getAllDevices = exports.saveDevices = void 0;
const db_1 = require("./db");
const logger_1 = __importDefault(require("../logger"));
const device_utils_1 = require("../device-utils");
function saveDevices(devices) {
    const connectedDeviceIds = new Set(devices.map((device) => device.udid));
    const devicesInDB = db_1.DeviceModel.chain().find().data();
    /**
     * Previously connected devices which are not identified remove.
     */
    db_1.DeviceModel.chain()
        .find({ udid: { $nin: [...connectedDeviceIds] } }) // $nin => not in condition
        .remove();
    /**
     * Check if the device is disconnected and remove from the DB instance.
     */
    devicesInDB.forEach((device) => {
        const isDeviceConneted = devices.find((d) => d.udid === device.udid && device.host === d.host);
        if (!isDeviceConneted) {
            db_1.DeviceModel.chain().find({ udid: device.udid, host: device.host }).remove();
        }
    });
    /**
     * If the newly identified devices are not in the database, then add them to the database
     */
    devices.forEach(function (device) {
        const isDeviceAlreadyPresent = devicesInDB.find((d) => d.udid === device.udid && device.host === d.host);
        if (!isDeviceAlreadyPresent) {
            db_1.DeviceModel.insert(Object.assign(Object.assign({}, device), { offline: false }));
        }
    });
    /**
     * Update the Latest Simulator state in DB
     */
    devices.forEach(function (device) {
        const allDevices = db_1.DeviceModel.chain().find().data();
        if (allDevices.length != 0 && device.deviceType === 'simulator') {
            const { state } = allDevices.find((d) => d.udid === device.udid);
            if (state !== device.state) {
                db_1.DeviceModel.chain()
                    .find({ udid: device.udid })
                    .update(function (d) {
                    d.state = device.state;
                });
            }
        }
    });
}
exports.saveDevices = saveDevices;
function getAllDevices() {
    return db_1.DeviceModel.chain().find().data();
}
exports.getAllDevices = getAllDevices;
function getDevice(filterOptions) {
    const filter = {
        platform: filterOptions.platform,
        name: { $contains: filterOptions.name || '' },
        busy: filterOptions.busy,
    };
    if (filterOptions.platformVersion) {
        filter.sdk = filterOptions.platformVersion;
    }
    if (filterOptions.udid) {
        filter.udid = { $in: filterOptions.udid };
    }
    if (filterOptions.minSDK) {
        filter.sdk = { $gte: filterOptions.minSDK };
    }
    if (filterOptions.deviceType === 'simulator') {
        filter.state = 'Booted';
        if (db_1.DeviceModel.chain().find(filter).data()[0] != undefined) {
            logger_1.default.info('Picking up booted simulator');
            return db_1.DeviceModel.chain().find(filter).data()[0];
        }
        else {
            filter.state = 'Shutdown';
        }
    }
    return db_1.DeviceModel.chain().find(filter).data()[0];
}
exports.getDevice = getDevice;
function updateDevice(device, updateData) {
    db_1.DeviceModel.chain()
        .find({
        udid: device.udid,
    })
        .update(function (device) {
        Object.assign(device, Object.assign({}, updateData));
    });
}
exports.updateDevice = updateDevice;
function updateCmdExecutedTime(sessionId) {
    db_1.DeviceModel.chain()
        .find({ session_id: sessionId })
        .update(function (device) {
        device.lastCmdExecutedAt = new Date().getTime();
    });
}
exports.updateCmdExecutedTime = updateCmdExecutedTime;
function unblockDevice(sessionId) {
    const device = db_1.DeviceModel.chain().find({ session_id: sessionId }).data()[0];
    const sessionStart = device.sessionStartTime;
    const currentTime = new Date().getTime();
    const utilization = currentTime - sessionStart;
    const totalUtilization = device.totalUtilizationTimeMilliSec + utilization;
    (0, device_utils_1.setUtilizationTime)(device.udid, totalUtilization);
    db_1.DeviceModel.chain()
        .find({
        session_id: sessionId,
    })
        .update(function (device) {
        device.session_id = undefined;
        device.busy = false;
        device.lastCmdExecutedAt = undefined;
        device.sessionStartTime = 0;
        device.totalUtilizationTimeMilliSec = totalUtilization;
        device.newCommandTimeout = undefined;
    });
}
exports.unblockDevice = unblockDevice;
