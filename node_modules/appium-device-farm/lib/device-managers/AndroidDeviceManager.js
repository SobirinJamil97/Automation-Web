"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("../helpers");
const appium_adb_1 = require("appium-adb");
const logger_1 = __importDefault(require("../logger"));
const lodash_1 = __importStar(require("lodash"));
const support_1 = require("@appium/support");
const DeviceFactory_1 = require("./factory/DeviceFactory");
const ChromeDriverManager_1 = __importDefault(require("./ChromeDriverManager"));
const typedi_1 = require("typedi");
const device_utils_1 = require("../device-utils");
class AndroidDeviceManager {
    constructor() {
        this.adbAvailable = true;
        this.getDeviceName = (adbInstance, udid) => __awaiter(this, void 0, void 0, function* () { return yield this.getDeviceProperty(adbInstance, udid, 'ro.product.name'); });
    }
    getDevices(deviceTypes, existingDeviceDetails, cliArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.adbAvailable) {
                return [];
            }
            const deviceState = [];
            const hosts = cliArgs.plugin['device-farm'].remote;
            try {
                for (const host of hosts) {
                    if (!(0, lodash_1.isObject)(host) && host.includes('127.0.0.1')) {
                        yield this.fetchLocalAndroidDevices(deviceState, existingDeviceDetails, cliArgs);
                    }
                    else {
                        yield this.fetchRemoteAndroidDevices(host, deviceState, 'android');
                    }
                }
                if (deviceTypes.androidDeviceType === 'real') {
                    return deviceState.filter((device) => {
                        return device.deviceType === 'real';
                    });
                }
                else if (deviceTypes.androidDeviceType === 'simulated') {
                    return deviceState.filter((device) => {
                        return device.deviceType === 'emulator';
                    });
                    // return both real and simulated (emulated) devices
                }
                else {
                    return deviceState;
                }
            }
            catch (e) {
                console.log(e);
            }
        });
    }
    fetchRemoteAndroidDevices(host, deviceState, platform) {
        return __awaiter(this, void 0, void 0, function* () {
            const devices = DeviceFactory_1.DeviceFactory.deviceInstance(host, deviceState, platform);
            return devices === null || devices === void 0 ? void 0 : devices.getDevices();
        });
    }
    fetchLocalAndroidDevices(deviceState, existingDeviceDetails, cliArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.requireSdkRoot();
            const connectedDevices = yield this.getConnectedDevices(cliArgs);
            for (const [adbInstance, devices] of connectedDevices) {
                yield (0, helpers_1.asyncForEach)(devices, (device) => __awaiter(this, void 0, void 0, function* () {
                    device.adbRemoteHost =
                        adbInstance.adbRemoteHost === null ? '127.0.0.1' : adbInstance.adbRemoteHost;
                    if (!deviceState.find((devicestate) => devicestate.udid === device.udid && devicestate.adbRemoteHost === device.adbRemoteHost)) {
                        const existingDevice = existingDeviceDetails.find((dev) => dev.udid === device.udid && dev.host.includes('127.0.0.1'));
                        if (existingDevice) {
                            logger_1.default.info(`Android Device details for ${device.udid} already available`);
                            deviceState.push(Object.assign(Object.assign({}, existingDevice), { busy: false }));
                        }
                        else {
                            logger_1.default.info(`Android Device details for ${device.udid} not available. So querying now.`);
                            const systemPort = yield (0, helpers_1.getFreePort)();
                            const totalUtilizationTimeMilliSec = yield (0, device_utils_1.getUtilizationTime)(device.udid);
                            const [sdk, realDevice, name, chromeDriverPath] = yield Promise.all([
                                this.getDeviceVersion(adbInstance, device.udid),
                                this.isRealDevice(adbInstance, device.udid),
                                this.getDeviceName(adbInstance, device.udid),
                                this.getChromeVersion(adbInstance, device.udid, cliArgs),
                            ]);
                            const host = adbInstance.adbHost != null ? adbInstance.adbHost : '127.0.0.1';
                            deviceState.push({
                                adbRemoteHost: adbInstance.adbHost,
                                adbPort: adbInstance.adbPort,
                                systemPort,
                                sdk,
                                realDevice,
                                name,
                                busy: false,
                                state: device.state,
                                udid: device.udid,
                                platform: 'android',
                                deviceType: realDevice ? 'real' : 'emulator',
                                host: `http://${host}:${cliArgs.port}`,
                                totalUtilizationTimeMilliSec: totalUtilizationTimeMilliSec,
                                sessionStartTime: 0,
                                chromeDriverPath,
                            });
                        }
                    }
                }));
            }
            return deviceState;
        });
    }
    getAdb() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.adb) {
                    this.adb = yield appium_adb_1.ADB.createADB();
                }
            }
            catch (e) {
                this.adbAvailable = false;
            }
            return this.adb;
        });
    }
    getConnectedDevices(cliArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const deviceList = new Map();
            const originalADB = yield this.getAdb();
            deviceList.set(originalADB, yield originalADB.getConnectedDevices());
            const adbRemote = cliArgs.plugin['device-farm'].adbRemote;
            if (adbRemote !== undefined && adbRemote.length > 0) {
                yield (0, helpers_1.asyncForEach)(adbRemote, (value) => __awaiter(this, void 0, void 0, function* () {
                    const adbRemoteValue = value.split(':');
                    console.log(adbRemoteValue, value);
                    const adbHost = adbRemoteValue[0];
                    const adbPort = adbRemoteValue[1] || 5037;
                    const cloneAdb = originalADB.clone({
                        remoteAdbHost: adbHost,
                        adbPort,
                    });
                    deviceList.set(cloneAdb, yield cloneAdb.getConnectedDevices());
                }));
            }
            return deviceList;
        });
    }
    getChromeVersion(adbInstance, udid, cliArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            if (cliArgs.plugin['device-farm'].skipChromeDownload) {
                logger_1.default.warn('skipChromeDownload server arg is set; skipping Chromedriver installation.');
                logger_1.default.warn('Android web/hybrid testing will not be possible without Chromedriver.');
                return;
            }
            logger_1.default.debug('Getting package info for chrome');
            const chromeDriverManager = typedi_1.Container.get(ChromeDriverManager_1.default);
            let versionName = '';
            try {
                const stdout = yield (yield adbInstance).adbExec(['-s', udid, 'shell', 'dumpsys', 'package', 'com.android.chrome']);
                const versionNameMatch = new RegExp(/versionName=([\d+.]+)/).exec(stdout);
                if (versionNameMatch) {
                    versionName = versionNameMatch[1];
                    versionName = versionName.split('.')[0];
                    return yield chromeDriverManager.downloadChromeDriver(versionName);
                }
            }
            catch (err) {
                logger_1.default.warn(`Error '${err.message}' while dumping package info`);
            }
        });
    }
    downloadChromeDriver(version) {
        return __awaiter(this, void 0, void 0, function* () {
            const instance = yield ChromeDriverManager_1.default.getInstance();
            return yield instance.downloadChromeDriver(version);
        });
    }
    getDeviceVersion(adbInstance, udid) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.getDeviceProperty(adbInstance, udid, 'ro.build.version.release');
        });
    }
    getDeviceProperty(adbInstance, udid, prop) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (yield adbInstance).adbExec(['-s', udid, 'shell', 'getprop', prop]);
        });
    }
    isRealDevice(adbInstance, udid) {
        return __awaiter(this, void 0, void 0, function* () {
            const character = yield this.getDeviceProperty(adbInstance, udid, 'ro.build.characteristics');
            return character !== 'emulator';
        });
    }
    requireSdkRoot() {
        return __awaiter(this, void 0, void 0, function* () {
            const sdkRoot = (0, appium_adb_1.getSdkRootFromEnv)();
            const docMsg = 'Read https://developer.android.com/studio/command-line/variables for more details';
            if (lodash_1.default.isEmpty(sdkRoot)) {
                throw new Error(`Neither ANDROID_HOME nor ANDROID_SDK_ROOT environment variable was exported. ${docMsg}`);
            }
            if (!(yield support_1.fs.exists(sdkRoot))) {
                throw new Error(`The Android SDK root folder '${sdkRoot}' does not exist on the local file system. ${docMsg}`);
            }
            const stats = yield support_1.fs.stat(sdkRoot);
            if (!stats.isDirectory()) {
                throw new Error(`The Android SDK root '${sdkRoot}' must be a folder. ${docMsg}`);
            }
            return sdkRoot;
        });
    }
}
exports.default = AndroidDeviceManager;
