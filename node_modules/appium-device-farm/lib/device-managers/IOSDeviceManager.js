"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_simctl_1 = __importDefault(require("node-simctl"));
const lodash_1 = require("lodash");
const appium_ios_device_1 = require("appium-ios-device");
const helpers_1 = require("../helpers");
const helpers_2 = require("../helpers");
const logger_1 = __importDefault(require("../logger"));
const axios_1 = __importDefault(require("axios"));
const DeviceFactory_1 = require("./factory/DeviceFactory");
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const device_utils_1 = require("../device-utils");
const fs_extra_1 = __importDefault(require("fs-extra"));
const logger_2 = __importDefault(require("../logger"));
class IOSDeviceManager {
    /**
     * Method to get all ios devices and simulators
     *
     * @returns {Promise<Array<IDevice>>}
     */
    getDevices(deviceTypes, existingDeviceDetails, cliArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, helpers_1.isMac)()) {
                return [];
            }
            else {
                if (deviceTypes.iosDeviceType === 'real') {
                    return (0, lodash_1.flatten)(yield Promise.all([this.getRealDevices(existingDeviceDetails, cliArgs)]));
                }
                else if (deviceTypes.iosDeviceType === 'simulated') {
                    return (0, lodash_1.flatten)(yield Promise.all([this.getSimulators(cliArgs)]));
                    // return both real and simulated devices
                }
                else {
                    return (0, lodash_1.flatten)(yield Promise.all([
                        this.getRealDevices(existingDeviceDetails, cliArgs),
                        this.getSimulators(cliArgs),
                    ]));
                }
            }
        });
    }
    getConnectedDevices() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield appium_ios_device_1.utilities.getConnectedDevices();
        });
    }
    getOSVersion(udid) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield appium_ios_device_1.utilities.getOSVersion(udid);
        });
    }
    getDeviceName(udid) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield appium_ios_device_1.utilities.getDeviceName(udid);
        });
    }
    getDevicePlatformName(name) {
        return name.toLowerCase().includes('tv') ? 'tvos' : 'ios';
    }
    /**
     * Method to get all ios real devices
     *
     * @returns {Promise<Array<IDevice>>}
     */
    getRealDevices(existingDeviceDetails, cliArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const deviceState = [];
            const hosts = cliArgs.plugin['device-farm'].remote;
            for (const host of hosts) {
                if (!(0, lodash_1.isObject)(host) && host.includes('127.0.0.1')) {
                    yield this.fetchLocalIOSDevices(existingDeviceDetails, deviceState, cliArgs);
                }
                else {
                    yield this.fetchRemoteIOSDevices(host, deviceState, 'ios');
                }
            }
            return deviceState;
        });
    }
    fetchRemoteIOSDevices(host, deviceState, platform) {
        return __awaiter(this, void 0, void 0, function* () {
            const devices = DeviceFactory_1.DeviceFactory.deviceInstance(host, deviceState, platform);
            return devices === null || devices === void 0 ? void 0 : devices.getDevices();
        });
    }
    derivedDataPath(cliArgs, udid, realDevice) {
        const derivedDataPath = cliArgs.plugin['device-farm'].derivedDataPath;
        function derivedPathExtracted(tmpPath, derivedDataPath) {
            if (derivedDataPath !== undefined) {
                fs_extra_1.default.copySync(derivedDataPath, tmpPath);
            }
            else {
                if (!fs_extra_1.default.existsSync(tmpPath)) {
                    logger_2.default.info(`DerivedDataPath for UDID ${udid} not set, so falling back to ${tmpPath}`);
                    logger_2.default.info(`WDA will be build once and will use WDA Runner from path ${tmpPath}, second test run will skip the build process`);
                    fs_extra_1.default.mkdirSync(tmpPath, { recursive: true });
                }
            }
        }
        if (derivedDataPath) {
            if (typeof derivedDataPath !== 'object')
                throw new Error('DerivedData Path should be able Object');
            const tmpPath = path_1.default.join(os_1.default.homedir(), `Library/Developer/Xcode/DerivedData/WebDriverAgent-${udid}`);
            if (realDevice) {
                derivedPathExtracted(tmpPath, derivedDataPath.device);
            }
            else {
                derivedPathExtracted(tmpPath, derivedDataPath.simulator);
            }
            return tmpPath;
        }
        else {
            return path_1.default.join(os_1.default.homedir(), `Library/Developer/Xcode/DerivedData/WebDriverAgent-${udid}`);
        }
    }
    fetchLocalIOSDevices(existingDeviceDetails, deviceState, cliArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const devices = yield this.getConnectedDevices();
            yield (0, helpers_2.asyncForEach)(devices, (udid) => __awaiter(this, void 0, void 0, function* () {
                const existingDevice = existingDeviceDetails.find((device) => device.udid === udid);
                if (existingDevice) {
                    logger_1.default.info(`IOS Device details for ${udid} already available`);
                    deviceState.push(Object.assign(Object.assign({}, existingDevice), { busy: false }));
                }
                else {
                    logger_1.default.info(`IOS Device details for ${udid} not available. So querying now.`);
                    const wdaLocalPort = yield (0, helpers_1.getFreePort)();
                    const mjpegServerPort = yield (0, helpers_1.getFreePort)();
                    const totalUtilizationTimeMilliSec = yield (0, device_utils_1.getUtilizationTime)(udid);
                    const [sdk, name] = yield Promise.all([this.getOSVersion(udid), this.getDeviceName(udid)]);
                    deviceState.push(Object.assign({
                        wdaLocalPort,
                        mjpegServerPort,
                        udid,
                        sdk,
                        name,
                        busy: false,
                        realDevice: true,
                        deviceType: 'real',
                        platform: this.getDevicePlatformName(name),
                        host: `http://127.0.0.1:${cliArgs.port}`,
                        totalUtilizationTimeMilliSec: totalUtilizationTimeMilliSec,
                        sessionStartTime: 0,
                        derivedDataPath: this.derivedDataPath(cliArgs, udid, true),
                    }));
                }
            }));
        });
    }
    /**
     * Method to get all ios simulators
     *
     * @returns {Promise<Array<IDevice>>}
     */
    getSimulators(cliArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const hosts = cliArgs.plugin['device-farm'].remote;
            const simulators = [];
            for (const host of hosts) {
                if (!(0, lodash_1.isObject)(host) && host.includes('127.0.0.1')) {
                    yield this.fetchLocalSimulators(simulators, cliArgs);
                }
                else {
                    yield this.fetchRemoteSimulators(host, simulators);
                }
            }
            simulators.sort((a, b) => (a.state > b.state ? 1 : -1));
            return simulators;
        });
    }
    fetchRemoteSimulators(host, simulators) {
        return __awaiter(this, void 0, void 0, function* () {
            const remoteDevices = (yield axios_1.default.get(`${host}/device-farm/api/devices/ios`)).data;
            remoteDevices.filter((device) => {
                if (device.deviceType === 'simulator') {
                    delete device['meta'];
                    delete device['$loki'];
                    simulators.push(Object.assign(Object.assign(Object.assign({}, device), { host: `${host}` })));
                }
            });
        });
    }
    fetchLocalSimulators(simulators, cliArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const flattenValued = yield this.getLocalSims();
            let filteredSimulators = [];
            const hasUserGivenSimulators = Object.hasOwn(cliArgs.plugin['device-farm'], 'simulators');
            if (hasUserGivenSimulators) {
                filteredSimulators = flattenValued.filter((device) => cliArgs.plugin['device-farm'].simulators.some((simulator) => device.name === simulator.name && device.sdk === simulator.sdk));
            }
            const buildSimulators = !(0, lodash_1.isEmpty)(filteredSimulators) ? filteredSimulators : flattenValued;
            yield (0, helpers_2.asyncForEach)(buildSimulators, (device) => __awaiter(this, void 0, void 0, function* () {
                const wdaLocalPort = yield (0, helpers_1.getFreePort)();
                const mjpegServerPort = yield (0, helpers_1.getFreePort)();
                const totalUtilizationTimeMilliSec = yield (0, device_utils_1.getUtilizationTime)(device.udid);
                simulators.push(Object.assign(Object.assign(Object.assign({}, device), { wdaLocalPort,
                    mjpegServerPort, busy: false, realDevice: false, platform: this.getDevicePlatformName(device.name), deviceType: 'simulator', host: `http://127.0.0.1:${cliArgs.port}`, totalUtilizationTimeMilliSec: totalUtilizationTimeMilliSec, sessionStartTime: 0, derivedDataPath: this.derivedDataPath(cliArgs, device.udid, false) })));
            }));
        });
    }
    getLocalSims() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const simctl = yield new node_simctl_1.default();
                const iOSSimulators = Object.keys(yield simctl.getDevices(null, 'iOS')).length;
                const tvSimulators = Object.keys(yield simctl.getDevices(null, 'tvOS')).length;
                let iosSimulators = [];
                let tvosSimulators = [];
                if (iOSSimulators) {
                    iosSimulators = (0, lodash_1.flatten)(Object.values((yield simctl.getDevicesByParsing('iOS'))));
                }
                else {
                    console.log('No iOS simulators found!');
                }
                if (tvSimulators) {
                    tvosSimulators = (0, lodash_1.flatten)(Object.values((yield simctl.getDevicesByParsing('tvOS'))));
                }
                else {
                    console.log('No tvOS simulators found!');
                }
                return [...iosSimulators, ...tvosSimulators];
            }
            catch (error) {
                console.error(error);
            }
        });
    }
}
exports.default = IOSDeviceManager;
