"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cronReleaseBlockedDevices = exports.releaseBlockedDevices = exports.refreshDeviceList = exports.updateDeviceList = exports.getBusyDevicesCount = exports.getDeviceFiltersFromCapability = exports.setUtilizationTime = exports.getUtilizationTime = exports.initlializeStorage = exports.updateCapabilityForDevice = exports.allocateDeviceForSession = exports.isDeviceConfigPathAbsolute = exports.isAndroidAndIOS = exports.isIOS = exports.isAndroid = exports.getDeviceTypeFromApp = void 0;
/* eslint-disable no-prototype-builtins */
const helpers_1 = require("./helpers");
const CapabilityManager_1 = require("./CapabilityManager");
const async_wait_until_1 = __importDefault(require("async-wait-until"));
const typedi_1 = require("typedi");
const device_managers_1 = require("./device-managers");
const device_service_1 = require("./data-service/device-service");
const logger_1 = __importDefault(require("./logger"));
const Platform_1 = __importDefault(require("./enums/Platform"));
const lodash_1 = __importDefault(require("lodash"));
const os_1 = __importDefault(require("os"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const CapabilityManager_2 = __importDefault(require("./device-managers/cloud/CapabilityManager"));
const DEVICE_AVAILABILITY_TIMEOUT = 180000;
const DEVICE_AVAILABILITY_QUERY_INTERVAL = 10000;
const customCapability = {
    deviceTimeOut: 'appium:deviceAvailabilityTimeout',
    deviceQueryInteval: 'appium:deviceRetryInterval',
    iphoneOnly: 'appium:iPhoneOnly',
    ipadOnly: 'appium:iPadOnly',
    udids: 'appium:udids',
    minSDK: 'appium:minSDK',
};
let timer;
let cronTimerToReleaseBlockedDevices;
const getDeviceTypeFromApp = (app) => {
    /* If the test is targeting safarim, then app capability will be empty */
    if (!app) {
        return;
    }
    return app.endsWith('app') || app.endsWith('zip') ? 'simulator' : 'real';
};
exports.getDeviceTypeFromApp = getDeviceTypeFromApp;
function isAndroid(cliArgs) {
    return cliArgs.Platform.toLowerCase() === Platform_1.default.ANDROID;
}
exports.isAndroid = isAndroid;
function isIOS(cliArgs) {
    return (0, helpers_1.isMac)() && cliArgs.Platform.toLowerCase() === Platform_1.default.IOS;
}
exports.isIOS = isIOS;
function isAndroidAndIOS(cliArgs) {
    return (0, helpers_1.isMac)() && cliArgs.Platform.toLowerCase() === Platform_1.default.BOTH;
}
exports.isAndroidAndIOS = isAndroidAndIOS;
function isDeviceConfigPathAbsolute(path) {
    if ((0, helpers_1.checkIfPathIsAbsolute)(path)) {
        return true;
    }
    else {
        throw new Error(`Device Config Path ${path} should be absolute`);
    }
}
exports.isDeviceConfigPathAbsolute = isDeviceConfigPathAbsolute;
/**
 * For given capability, wait untill a free device is available from the database
 * and update the capability json with required device informations
 * @param capability
 * @returns
 */
function allocateDeviceForSession(capability) {
    return __awaiter(this, void 0, void 0, function* () {
        const firstMatch = Object.assign({}, capability.firstMatch[0], capability.alwaysMatch);
        console.log(firstMatch);
        const filters = getDeviceFiltersFromCapability(firstMatch);
        logger_1.default.info(JSON.stringify(filters));
        const timeout = firstMatch[customCapability.deviceTimeOut] || DEVICE_AVAILABILITY_TIMEOUT;
        const newCommandTimeout = firstMatch['appium:newCommandTimeout'] || undefined;
        const intervalBetweenAttempts = firstMatch[customCapability.deviceQueryInteval] || DEVICE_AVAILABILITY_QUERY_INTERVAL;
        try {
            yield (0, async_wait_until_1.default)(() => __awaiter(this, void 0, void 0, function* () {
                const maxSessions = yield getDeviceManager().getMaxSessionCount();
                if (maxSessions !== undefined && (yield getBusyDevicesCount()) === maxSessions) {
                    logger_1.default.info(`Waiting for session available, already at max session count of: ${maxSessions}`);
                    return false;
                }
                else
                    logger_1.default.info('Waiting for free device');
                return (yield (0, device_service_1.getDevice)(filters)) != undefined;
            }), { timeout, intervalBetweenAttempts });
        }
        catch (err) {
            throw new Error(`No device found for filters: ${JSON.stringify(filters)}`);
        }
        const device = (0, device_service_1.getDevice)(filters);
        logger_1.default.info(`ðŸ“± Device found: ${JSON.stringify(device)}`);
        (0, device_service_1.updateDevice)(device, { busy: true, newCommandTimeout: newCommandTimeout });
        logger_1.default.info(`ðŸ“± Blocking device ${device.udid} for new session`);
        yield updateCapabilityForDevice(capability, device);
        return device;
    });
}
exports.allocateDeviceForSession = allocateDeviceForSession;
function updateCapabilityForDevice(capability, device) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!device.hasOwnProperty('cloud')) {
            if (device.platform.toLowerCase() == Platform_1.default.ANDROID) {
                yield (0, CapabilityManager_1.androidCapabilities)(capability, device);
            }
            else {
                yield (0, CapabilityManager_1.iOSCapabilities)(capability, device);
            }
        }
        else {
            logger_1.default.info('Updating cloud Capability for Device');
            return new CapabilityManager_2.default(capability, device).getCapability();
        }
    });
}
exports.updateCapabilityForDevice = updateCapabilityForDevice;
/**
 * Sets up node-persist storage in local cache
 * @returns storage
 */
function initlializeStorage() {
    return __awaiter(this, void 0, void 0, function* () {
        const basePath = path_1.default.join(os_1.default.homedir(), '.cache', 'appium-device-farm', 'storage');
        yield fs_1.default.promises.mkdir(basePath, { recursive: true });
        const storage = require('node-persist');
        const localStorage = storage.create({ dir: basePath });
        yield localStorage.init();
        typedi_1.Container.set('LocalStorage', localStorage);
    });
}
exports.initlializeStorage = initlializeStorage;
function getStorage() {
    return typedi_1.Container.get('LocalStorage');
}
/**
 * Gets utlization time for a device from storage
 * Returns 0 if the device has not been used an thus utilization time has not been saved
 * @param udid
 * @returns number
 */
function getUtilizationTime(udid) {
    return __awaiter(this, void 0, void 0, function* () {
        const value = yield getStorage().getItem(udid);
        if (value !== undefined) {
            return value;
        }
        return 0;
    });
}
exports.getUtilizationTime = getUtilizationTime;
/**
 * Sets utilization time for a device to storage
 * @param udid
 * @param utilizationTime
 */
function setUtilizationTime(udid, utilizationTime) {
    return __awaiter(this, void 0, void 0, function* () {
        yield getStorage().setItem(udid, utilizationTime);
    });
}
exports.setUtilizationTime = setUtilizationTime;
/**
 * Method to get the device filters from the custom session capability
 * This filter will be used as in the query to find the free device from the databse
 * @param capability
 * @returns IDeviceFilterOptions
 */
function getDeviceFiltersFromCapability(capability) {
    var _a;
    const platform = capability['platformName'].toLowerCase();
    const udids = capability[customCapability.udids]
        ? capability[customCapability.udids].split(',').map(lodash_1.default.trim)
        : (_a = process.env.UDIDS) === null || _a === void 0 ? void 0 : _a.split(',').map(lodash_1.default.trim);
    /* Based on the app file extension, we will decide whether to run the
     * test on real device or simulator.
     *
     * Applicaple only for ios.
     */
    const deviceType = platform == Platform_1.default.IOS && (0, helpers_1.isMac)()
        ? (0, exports.getDeviceTypeFromApp)(capability['appium:app'])
        : undefined;
    let name = '';
    if (capability[customCapability.ipadOnly]) {
        name = 'iPad';
    }
    else if (capability[customCapability.iphoneOnly]) {
        name = 'iPhone';
    }
    return {
        platform,
        platformVersion: capability['appium:platformVersion']
            ? capability['appium:platformVersion']
            : undefined,
        name,
        deviceType,
        udid: (udids === null || udids === void 0 ? void 0 : udids.length) ? udids : undefined,
        busy: false,
        minSDK: capability[customCapability.minSDK] ? capability[customCapability.minSDK] : undefined,
    };
}
exports.getDeviceFiltersFromCapability = getDeviceFiltersFromCapability;
/**
 * Helper methods to manage devices
 */
function getDeviceManager() {
    return typedi_1.Container.get(device_managers_1.DeviceFarmManager);
}
function getBusyDevicesCount() {
    return __awaiter(this, void 0, void 0, function* () {
        const allDevices = yield (0, device_service_1.getAllDevices)();
        return allDevices.filter((device) => {
            return device.busy === true;
        }).length;
    });
}
exports.getBusyDevicesCount = getBusyDevicesCount;
function updateDeviceList() {
    return __awaiter(this, void 0, void 0, function* () {
        const devices = yield getDeviceManager().getDevices((0, device_service_1.getAllDevices)());
        (0, device_service_1.saveDevices)(devices);
    });
}
exports.updateDeviceList = updateDeviceList;
function refreshDeviceList() {
    return __awaiter(this, void 0, void 0, function* () {
        if (timer) {
            clearInterval(timer);
        }
        yield updateDeviceList();
        timer = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            yield updateDeviceList();
        }), 10000);
    });
}
exports.refreshDeviceList = refreshDeviceList;
function releaseBlockedDevices() {
    return __awaiter(this, void 0, void 0, function* () {
        const allDevices = yield (0, device_service_1.getAllDevices)();
        const busyDevices = allDevices.filter((device) => {
            return device.busy === true && device.host.includes('127.0.0.1');
        });
        busyDevices.forEach(function (device) {
            const currentEpoch = new Date().getTime();
            const timeout = device.newCommandTimeout != undefined ? device.newCommandTimeout : 60;
            if (device.lastCmdExecutedAt != undefined &&
                (currentEpoch - device.lastCmdExecutedAt) / 1000 > timeout) {
                console.log(`ðŸ“± Found Device with udid ${device.udid} has no activity for more than ${timeout} seconds`);
                const sessionId = device.session_id;
                if (sessionId !== undefined) {
                    (0, device_service_1.unblockDevice)(sessionId);
                    logger_1.default.info(`ðŸ“± Unblocked device with udid ${device.udid} mapped to sessionId ${sessionId} as there is no activity from client for more than ${timeout} seconds`);
                }
            }
        });
    });
}
exports.releaseBlockedDevices = releaseBlockedDevices;
function cronReleaseBlockedDevices() {
    return __awaiter(this, void 0, void 0, function* () {
        if (cronTimerToReleaseBlockedDevices) {
            clearInterval(cronTimerToReleaseBlockedDevices);
        }
        yield releaseBlockedDevices();
        cronTimerToReleaseBlockedDevices = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            yield releaseBlockedDevices();
        }), 30000);
    });
}
exports.cronReleaseBlockedDevices = cronReleaseBlockedDevices;
